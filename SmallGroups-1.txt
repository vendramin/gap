gap> SmallGroupsInformation(21);

  There are 2 groups of order 21.

  The groups whose order factorises in at most 3 primes 
  have been classified by O. Hoelder. This classification is 
  used in the SmallGroups library. 

  This size belongs to layer 1 of the SmallGroups library. 
  IdSmallGroup is available for this size. 
 
gap> gr := SmallGroup(21,1);;
gap> IsAbelian(gr);
false
gap> Elements(gr);
[ <identity> of ..., f1, f2, f1^2, f1*f2, f2^2, f1^2*f2, f1*f2^2, f2^3, f1^2*f2^2, f1*f2^3, f2^4, f1^2*f2^3, f1*f2^4, f2^5, f1^2*f2^4, 
  f1*f2^5, f2^6, f1^2*f2^5, f1*f2^6, f1^2*f2^6 ]
gap> StructureDescription(gr);
"C7 : C3"
gap> # There is no simple group of order 84
gap> NrSmallGroups(84);
15
gap> AllGroups(Size, [84], IsSimple, true);
[  ]
gap> n := 84;;
gap> for k in [1..NrSmallGroups(84)] do
> gr := SmallGroup(84, k);
> if IsSimple(gr) then
> Degrees([n,k]);
> fi;
> od;
gap> # Lam-Leep: Each index-two subgroup of Aut(S6) is isomorphic to S6, PGL2(9) or M10
gap> S6 := SymmetricGroup(6);;
gap> autS6 := AutomorphismGroup(S6);;
gap> l := LowIndexSubgroups(autS6, 2);
[ <group of size 1440 with 3 generators>, <group of size 720 with 3 generators>, <group of size 720 with 3 generators>, 
  <group of size 720 with 3 generators> ]
gap> List(l, StructureDescription);
[ "(A6 . C2) : C2", "S6", "A6 . C2", "A6 : C2" ]
gap> List(l, IdGroup);
[ [ 1440, 5841 ], [ 720, 763 ], [ 720, 765 ], [ 720, 764 ] ]
gap> IdGroup(SymmetricGroup(6));
[ 720, 763 ]
gap> IdGroup(PGL(2,9));
[ 720, 764 ]
gap> IdGroup(MathieuGroup(10));
[ 720, 765 ]
gap> Order(autS6);
1440
gap> # Commutators!
gap> # [x,y]=x^(-1)*y^(-1)*x*y
gap> gr := SymmetricGroup(5);;
gap> x := Random(gr);;
gap> y := Random(gr);;
gap> x;
(1,2)
gap> y;
(2,5,3,4)
gap> Comm(x,y);
(1,2,5)
gap> x^(-1)*y^(-1)*x*y=Comm(x,y);
true
gap> commutators := function(gr)
> local x,y,l;
> l := [];
> for x in gr do
> for y in gr do
> Add(l, Comm(x,y));
> od;
> od;
> return Set(l);
> end;
function( gr ) ... end
gap> commutators(SymmetricGroup(3));
[ (), (1,2,3), (1,3,2) ]
gap> G := First(AllSmallGroups(Size, [2..200]), x->Order(DerivedSubgroup(x)) <> Size(commutators(x)));
<pc group of size 96 with 6 generators>
gap> Size(G);
96
gap> AsList(G);
[ <identity> of ..., f1, f2, f3, f4, f5, f6, f1^2, f1*f2, f1*f3, f1*f4, f1*f5, f1*f6, f2*f3, f2*f4, f2*f5, f2*f6, f3*f4, 
  f3*f5, f3*f6, f4*f5, f4*f6, f5*f6, f1^2*f2, f1^2*f3, f1^2*f4, f1^2*f5, f1^2*f6, f1*f2*f3, f1*f2*f4, f1*f2*f5, f1*f2*f6, 
  f1*f3*f4, f1*f3*f5, f1*f3*f6, f1*f4*f5, f1*f4*f6, f1*f5*f6, f2*f3*f4, f2*f3*f5, f2*f3*f6, f2*f4*f5, f2*f4*f6, f2*f5*f6, 
  f3*f4*f5, f3*f4*f6, f3*f5*f6, f4*f5*f6, f1^2*f2*f3, f1^2*f2*f4, f1^2*f2*f5, f1^2*f2*f6, f1^2*f3*f4, f1^2*f3*f5, f1^2*f3*f6, 
  f1^2*f4*f5, f1^2*f4*f6, f1^2*f5*f6, f1*f2*f3*f4, f1*f2*f3*f5, f1*f2*f3*f6, f1*f2*f4*f5, f1*f2*f4*f6, f1*f2*f5*f6, 
  f1*f3*f4*f5, f1*f3*f4*f6, f1*f3*f5*f6, f1*f4*f5*f6, f2*f3*f4*f5, f2*f3*f4*f6, f2*f3*f5*f6, f2*f4*f5*f6, f3*f4*f5*f6, 
  f1^2*f2*f3*f4, f1^2*f2*f3*f5, f1^2*f2*f3*f6, f1^2*f2*f4*f5, f1^2*f2*f4*f6, f1^2*f2*f5*f6, f1^2*f3*f4*f5, f1^2*f3*f4*f6, 
  f1^2*f3*f5*f6, f1^2*f4*f5*f6, f1*f2*f3*f4*f5, f1*f2*f3*f4*f6, f1*f2*f3*f5*f6, f1*f2*f4*f5*f6, f1*f3*f4*f5*f6, 
  f2*f3*f4*f5*f6, f1^2*f2*f3*f4*f5, f1^2*f2*f3*f4*f6, f1^2*f2*f3*f5*f6, f1^2*f2*f4*f5*f6, f1^2*f3*f4*f5*f6, f1*f2*f3*f4*f5*f6, 
  f1^2*f2*f3*f4*f5*f6 ]
gap> StructureDescription(G);
"((C4 x C2) : C4) : C3"
gap> IdGroup(G);
[ 96, 3 ]
gap> f := IsomorphismPermGroup(G);;
gap> f;
<action isomorphism>
gap> Image(f);
<permutation group of size 96 with 6 generators>
gap> P := Image(f);
<permutation group of size 96 with 6 generators>
gap> MovedPoints(P);
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 
  34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 
  65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 
  96 ]
gap> GeneratorsOfGroup(G);
[ f1, f2, f3, f4, f5, f6 ]
gap> GeneratorsOfGroup(P);
[ (1,2,8)(3,10,75)(4,60,24)(5,38,56)(6,68,57)(7,13,28)(9,25,40)(11,58,21)(12,83,22)(14,87,81)(15,67,74)(16,88,96)(17,35,92)(18,
    61,77)(19,85,78)(20,86,52)(23,36,26)(27,48,37)(29,93,46)(30,82,39)(31,94,89)(32,55,71)(33,76,42)(34,91,43)(41,62,53)(44,65,
    90)(45,84,79)(47,59,50)(49,72,66)(51,73,95)(54,70,63)(64,80,69), (1,3,21,42)(2,9,36,62)(4,41,45,89)(5,15,6,16)(7,17,48,
    72)(8,24,56,77)(10,61,65,95)(11,30,12,31)(13,32,68,87)(14,73,69,20)(18,70,19,71)(22,43,23,44)(25,76,80,96)(26,50,27,51)(28,
    52,83,93)(29,88,84,35)(33,85,34,86)(37,63,38,64)(39,47,40,46)(49,94,90,55)(53,91,54,92)(57,78,58,79)(59,67,60,66)(74,82,75,
    81), (1,4,5,18)(2,10,11,33)(3,14,15,39)(6,19,21,45)(7,20,22,46)(8,25,26,53)(9,29,30,59)(12,34,36,65)(13,35,37,66)(16,40,42,
    69)(17,41,43,70)(23,47,48,73)(24,49,50,74)(27,54,56,80)(28,55,57,81)(31,60,62,84)(32,61,63,85)(38,67,68,88)(44,71,72,
    89)(51,75,77,90)(52,76,78,91)(58,82,83,94)(64,86,87,95)(79,92,93,96), (1,5)(2,11)(3,15)(4,18)(6,21)(7,22)(8,26)(9,30)(10,
    33)(12,36)(13,37)(14,39)(16,42)(17,43)(19,45)(20,46)(23,48)(24,50)(25,53)(27,56)(28,57)(29,59)(31,62)(32,63)(34,65)(35,
    66)(38,68)(40,69)(41,70)(44,72)(47,73)(49,74)(51,77)(52,78)(54,80)(55,81)(58,83)(60,84)(61,85)(64,87)(67,88)(71,89)(75,
    90)(76,91)(79,93)(82,94)(86,95)(92,96), (1,6)(2,12)(3,16)(4,19)(5,21)(7,23)(8,27)(9,31)(10,34)(11,36)(13,38)(14,40)(15,
    42)(17,44)(18,45)(20,47)(22,48)(24,51)(25,54)(26,56)(28,58)(29,60)(30,62)(32,64)(33,65)(35,67)(37,68)(39,69)(41,71)(43,
    72)(46,73)(49,75)(50,77)(52,79)(53,80)(55,82)(57,83)(59,84)(61,86)(63,87)(66,88)(70,89)(74,90)(76,92)(78,93)(81,94)(85,
    95)(91,96), (1,7)(2,13)(3,17)(4,20)(5,22)(6,23)(8,28)(9,32)(10,35)(11,37)(12,38)(14,41)(15,43)(16,44)(18,46)(19,47)(21,
    48)(24,52)(25,55)(26,57)(27,58)(29,61)(30,63)(31,64)(33,66)(34,67)(36,68)(39,70)(40,71)(42,72)(45,73)(49,76)(50,78)(51,
    79)(53,81)(54,82)(56,83)(59,85)(60,86)(62,87)(65,88)(69,89)(74,91)(75,92)(77,93)(80,94)(84,95)(90,96) ]
gap> SmallerDegreePermutationRepresentation(P);
[ (1,2,8)(3,10,75)(4,60,24)(5,38,56)(6,68,57)(7,13,28)(9,25,40)(11,58,21)(12,83,22)(14,87,81)(15,67,74)(16,88,96)(17,35,92)(18,
    61,77)(19,85,78)(20,86,52)(23,36,26)(27,48,37)(29,93,46)(30,82,39)(31,94,89)(32,55,71)(33,76,42)(34,91,43)(41,62,53)(44,65,
    90)(45,84,79)(47,59,50)(49,72,66)(51,73,95)(54,70,63)(64,80,69), (1,3,21,42)(2,9,36,62)(4,41,45,89)(5,15,6,16)(7,17,48,
    72)(8,24,56,77)(10,61,65,95)(11,30,12,31)(13,32,68,87)(14,73,69,20)(18,70,19,71)(22,43,23,44)(25,76,80,96)(26,50,27,51)(28,
    52,83,93)(29,88,84,35)(33,85,34,86)(37,63,38,64)(39,47,40,46)(49,94,90,55)(53,91,54,92)(57,78,58,79)(59,67,60,66)(74,82,75,
    81), (1,6)(2,12)(3,16)(4,19)(5,21)(7,23)(8,27)(9,31)(10,34)(11,36)(13,38)(14,40)(15,42)(17,44)(18,45)(20,47)(22,48)(24,
    51)(25,54)(26,56)(28,58)(29,60)(30,62)(32,64)(33,65)(35,67)(37,68)(39,69)(41,71)(43,72)(46,73)(49,75)(50,77)(52,79)(53,
    80)(55,82)(57,83)(59,84)(61,86)(63,87)(66,88)(70,89)(74,90)(76,92)(78,93)(81,94)(85,95)(91,96), 
  (1,8,2)(3,75,10)(4,24,60)(5,56,38)(6,57,68)(7,28,13)(9,40,25)(11,21,58)(12,22,83)(14,81,87)(15,74,67)(16,96,88)(17,92,35)(18,
    77,61)(19,78,85)(20,52,86)(23,26,36)(27,37,48)(29,46,93)(30,39,82)(31,89,94)(32,71,55)(33,42,76)(34,43,91)(41,53,62)(44,90,
    65)(45,79,84)(47,50,59)(49,66,72)(51,95,73)(54,63,70)(64,69,80), (1,42,21,3)(2,62,36,9)(4,89,45,41)(5,16,6,15)(7,72,48,
    17)(8,77,56,24)(10,95,65,61)(11,31,12,30)(13,87,68,32)(14,20,69,73)(18,71,19,70)(22,44,23,43)(25,96,80,76)(26,51,27,50)(28,
    93,83,52)(29,35,84,88)(33,86,34,85)(37,64,38,63)(39,46,40,47)(49,55,90,94)(53,92,54,91)(57,79,58,78)(59,66,60,67)(74,81,75,
    82) ] -> [ (1,3,5)(2,4,6)(7,10,12)(8,9,11), (1,7)(2,8)(3,9,4,10)(11,12), (3,4)(5,6)(9,10)(11,12), 
  (1,5,3)(2,6,4)(7,12,10)(8,11,9), (1,7)(2,8)(3,10,4,9)(11,12) ]
gap> Q := Image(SmallerDegreePermutationRepresentation(P));
<permutation group with 6 generators>
gap> MovedPoints(Q);
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24 ]
gap> Q := Image(SmallerDegreePermutationRepresentation(P));
<permutation group with 6 generators>
gap> MovedPoints(Q);
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24 ]
gap> Q := Image(SmallerDegreePermutationRepresentation(P));
Group([ (1,3,5)(2,4,6)(7,11,9)(8,12,10), (3,9,4,10)(5,7)(6,8)(11,12), (3,4)(5,6)(7,8)(9,10), (1,5,3)(2,6,4)(7,9,11)(8,10,12), 
  (3,10,4,9)(5,7)(6,8)(11,12) ])
gap> MovedPoints(Q);
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ]
gap> Q;
Group([ (1,3,5)(2,4,6)(7,11,9)(8,12,10), (3,9,4,10)(5,7)(6,8)(11,12), (3,4)(5,6)(7,8)(9,10), (1,5,3)(2,6,4)(7,9,11)(8,10,12), 
  (3,10,4,9)(5,7)(6,8)(11,12) ])
gap> GeneratorsOfGroup(Q);
[ (1,3,5)(2,4,6)(7,11,9)(8,12,10), (3,9,4,10)(5,7)(6,8)(11,12), (3,4)(5,6)(7,8)(9,10), (1,5,3)(2,6,4)(7,9,11)(8,10,12), 
  (3,10,4,9)(5,7)(6,8)(11,12) ]
gap> SmallGeneratingSet(Q);
[ (1,3,5)(2,4,6)(7,11,9)(8,12,10), (3,9,4,10)(5,8)(6,7)(11,12) ]
gap> IdGroup(Q);
[ 96, 3 ]
gap> # I want G and H finite groups, G solvable, H not solvable and cs(G)=cs(H)
gap> cs := function(group)
> return Set(List(ConjugacyClasses(group), Size));
> end;
function( group ) ... end
gap> cs(SymmetricGroup(3));
[ 1, 2, 3 ]
gap> cs(SymmetricGroup(4));
[ 1, 3, 6, 8 ]
gap> cs(SL(2,3));
[ 1, 4, 6 ]
gap> cs(AlternatingGroup(4));
[ 1, 3, 4 ]
gap> G := DirectProduct(SmallGroup(240,13), SmallGroup(960,1019));;
gap> H := DirectProduct(SmallGroup(960,239), SmallGroup(480,959));;
gap> IsSolvable(G);
true
gap> IsSolvable(H);
false
gap> Order(G);
230400
gap> Order(H);
460800
gap> cs(G);
[ 1, 2, 4, 8, 12, 16, 20, 24, 30, 40, 48, 60, 80, 96, 120, 160, 192, 240, 288, 320, 360, 480, 576, 600, 720, 800, 900, 960, 
  1200, 1440, 1600, 1800, 2400 ]
gap> # G nilpotent, Z(H)=1 and cs(G)=cs(H)
gap> G := DirectProduct(DihedralGroup(8), SmallGroup(243,26));;
gap> H := SmallGroup(486,36);;
gap> IsTrivial(Center(H));
true
gap> IsNilpotent(G);
true
gap> cs(G)=cs(H);
true
gap> # Ex1
gap> gr := SL(2,5);;
gap> subgroups := AllSubgroups(gr);;
gap> Size(subgroups);
76
gap> A5 := AlternatingGroup(5);;
gap> IdGroup(A5);
[ 60, 5 ]
gap> last in List(subgroups, IdGroup);
false
gap> 
