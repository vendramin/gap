\chapter{First steps}
\label{first} 

\section{The very first steps}
\label{section:primeros_pasos}

Immediately after running~\GAP~we will see some information related to the
distribution we have installed.  This information includes software version
number and the packages loaded in memory. 
We will also see that~\GAP~is ready:
\begin{lstlisting}
gap>
\end{lstlisting}

To close~\GAP~one uses \lstinline{quit}:
\begin{lstlisting}
gap> quit;
\end{lstlisting}

Every command should end with the symbol \lstinline{;} (semicolon). The symbol
\lstinline{;;} (double semicolon) also is used to end a command but it means
that no screen output will be produced. 

\begin{lstlisting}
gap> 2+5;;
gap> 2+5;
7
\end{lstlisting}

To see information related commands or functions, tutorials and manuals one
uses the symbol \lstinline{?} (question mark). Here we have some examples:
\begin{lstlisting}
gap> ?tutorial
gap> ?sets
gap> ?help
gap> ?permutations
gap> ?Eigenvalues
gap> ?CyclicGroup
gap> ?FreeGroup
gap> ?SylowSubgroup
\end{lstlisting}

To write comments one uses the symbol \lstinline{#} (number sign or hash) as
the following example shows:
\begin{lstlisting}
gap> # This is just a comment!
\end{lstlisting}

To make the command line more readable one could use
the symbol \lstinline{\} (backslash):
\begin{lstlisting}
gap> # Let us compute 1+2+3
gap> 1\
> +2\
> +3;
6
\end{lstlisting}

The function \lstinline{LogTo} saves the subsequent interaction to be logged to
a file. It means that everything you see on your terminal will also appear in
this file. This is extremely useful.  When the function \lstinline{LogTo} is
called with no parameters~\GAP~will stop writing a log file.
\begin{lstlisting}
gap> # Save the output to the file mylog
gap> LogTo("mylog");
gap> # Stop saving the output
gap> LogTo();
\end{lstlisting}
%FIXME
%SizeScreen

\lstinline{NamesUserGVars} returns the names 
of the global variables created by the user. \lstinline{MemoryUsage} returns 
the bytes used by a variable. Example:
\begin{lstlisting}
gap> p := 2^30;;
gap> NamesUserGVars();
[ "p" ]
gap> s := "a string";;
gap> NamesUserGVars();
[ "p", "s" ]
gap> MemoryUsage(p);
8
\end{lstlisting}

\lstinline{SaveWorkspace} saves an image of the memory into a file.  Later one
can recover this image by calling~\GAP~ as follows: 
\begin{lstlisting}
gap -L <workspace>
\end{lstlisting}

%The function \lstinline{PageSource} will show us the code 
%more memory!

\section{Basic arithmetics}

One can do basic arithmetic operations with rational numbers:
\begin{lstlisting}
gap> 1+1;
2
gap> 2*3;
6
gap> 8/2;
4
gap> (1/3)+(2/5);
11/15
gap> 2^(-4);
1/16
gap> 2*(-6)+4;
-8
gap> (1-5^2)^2-2*(2+4*2)^2;
376
gap> NumeratorRat(3/5);
3
gap> DenominatorRat(3/5);
5
\end{lstlisting}
One uses \lstinline{mod} to obtain the remainder after division of $a$ by $m$,
where $a$ is the dividend and $m$ is the divisor.  Examples: 
\begin{lstlisting}
gap> 6 mod 4;
2
gap> -6 mod 5;
4
\end{lstlisting}
There are several functions that one can use for specific purposes. For example 
\lstinline{Factors} returns the factorization of an integer and 
\lstinline{IsPrime} detects whether an integer is prime or not.
\begin{lstlisting}
gap> Factors(10);
[ 2, 5 ]
gap> Factors(18);
[ 2, 3, 3 ]
gap> Factors(1800);
[ 2, 2, 2, 3, 3, 5, 5 ]
gap> IsPrime(1800);
false
gap> Factors(37);
[ 37 ]
gap> IsPrime(37);
true
\end{lstlisting}
Other useful functions: \lstinline{Sqrt} computes square roots, 
\lstinline{Factorial} computes the factorial of a positive integer, 
\lstinline{Gcd} computes the greatest common divisor of a finite list of integers, 
\lstinline{Lcm} computes the least commom multiple. 
\begin{lstlisting}
gap> Sqrt(25);
5
gap> Factorial(15);
1307674368000
gap> Gcd(10,4);
2
gap> Lcm(10,4,2,6);
60
\end{lstlisting}

We can also work in cyclotomic fields.  \lstinline{CF} creates a cyclotomic
field. To create primitive roots of $1$ one uses the function \lstinline{E}.
More precisely: \lstinline{E(n)} returns $e^{2\pi i/n}$. Tipically, cyclotomic
numbers will be represented as rational linear combinations of primitive roots
of $1$. Examples:
\begin{lstlisting}
gap> E(6) in Rationals;
false 
gap> E(6) in Cyclotomics;
true
gap> E(3) in CF(3);
true
gap> E(3) in CF(4);
false
gap> E(3)^2+E(3);
-1
gap> E(5)^5-E(5);
-2*E(5)-E(5)^2-E(5)^3-E(5)^4
gap> E(6);
-E(3)^2
\end{lstlisting}
\lstinline{Inverse} (resp. \lstinline{AdditiveInverse}) returns 
the multiplicative (resp. additive) inverse of an element. 
\begin{lstlisting}
gap> AdditiveInverse(2/3);
-2/3
gap> Inverse(2/3);
3/2
gap> AdditiveInverse(E(7));
-E(7)
gap> Inverse(E(7));
E(7)^6
\end{lstlisting}

\GAP~can work with very large numbers. 
Let us see some nice examples:

\begin{example}
	One can easily prove that $n=164$ is the largest integer such that $7^n$
	divides $1000!$:
\begin{lstlisting}
gap> Factorial(1000) mod 7^164;
0
gap> Factorial(1000) mod 7^165 = 0;
false
\end{lstlisting}
\end{example}

\begin{example}
Let us compute $999^{179}\bmod 1793$:
\begin{lstlisting}
gap> 999^179 mod 1763;
1219
\end{lstlisting}
\end{example}

The following example appears in \texttt{Mathoverflow}, question \#282035. Can you prove
the result without using a computer software?

\begin{example}
	The sum of digits of $3^{1000}$ is divisible by $7$: %\footnote{Can you prove this without a computer algebra package?}.
	%The sum of the $432$
	%digits of the number $3^{1000}$ is $2142$ and this number is divisible by
	%$7$:
	%gap> Sum(ListOfDigits(3^1000));
	%2142
	%gap> Size(ListOfDigits(3^1000));
	%478
\begin{lstlisting}
gap> Sum(ListOfDigits(3^1000)) mod 7;
0
\end{lstlisting}
\end{example}


\subsection*{Finite fields}
To create the finite field of $p^n$
elements (here $p$ is a prime number) we use the function \lstinline{GF}.  The
characteristic of a field can be obtained with \lstinline{Characteristic}. 
\begin{lstlisting}
gap> GF(2);                                                           
GF(2)
gap> GF(4);
GF(2^2)
gap> GF(9);
GF(3^2)
gap> Characteristic(Rationals);
0
gap> Characteristic(CF(3));
0
gap> Characteristic(CF(4));
0
gap> Characteristic(GF(2));
2
gap> Characteristic(GF(9));
3
\end{lstlisting}

Let $p$ be a prime number and let $F$ denote the field with $q\coloneqq p^n$ elements, for some $n\in\N$. 
The subset 
\[
  \{x\in F:x\ne 0\}
\]
is a cyclic group of size $q-1$; say generated by $\zeta$. Then
$F=\{0,\zeta,\zeta^2,\dots,\zeta^{q-1}\}$, so each non-zero element of $F$ is
then a power of $\zeta$.  

In~\GAP~each non-zero element of the finite field
\lstinline{GF(q)} will be a power of the generator \lstinline{Z(q)}. The zero
of \lstinline{GF(q)} will be \lstinline{0*Z(q)} or equivalently
\lstinline{Zero(GF(q))}. \lstinline{One(GF(q))} will be the multiplicative
neutral element of \lstinline{GF(q)}. 
\begin{lstlisting}
gap> Size(GF(4));
4
gap> Elements(GF(4));
[ 0*Z(2), Z(2)^0, Z(2^2), Z(2^2)^2 ]
gap> Z(4);
Z(2^2)
gap> Inverse(Z(4));
Z(2^2)^2
gap> Zero(GF(4));
0*Z(2)
gap> 0 in GF(4);
false
gap> Zero(Rationals);
0
gap> One(GF(4));
Z(2)^0
gap> 1 in GF(4);
false
gap> One(Rationals);
1
\end{lstlisting}

To recognize elements in finite fields with a prime number of elements one uses
the function \lstinline{Int}. Examples:
\begin{lstlisting}
gap> Elements(GF(5));
[ 0*Z(5), Z(5)^0, Z(5), Z(5)^2, Z(5)^3 ]
gap> Int(Z(5)^0);
1
gap> Int(Z(5)^1);
2
gap> Int(Z(5)^2);
4
gap> Int(Z(5)^3);
3
\end{lstlisting}

\section{Basic programming}
\label{programming}

\subsection*{Objects and variables}

An object is something that we can assign to a variable. So an object could be
either a number, a string, a group, a field, an element of a group, a group
homomorphism, a ring, a matrix, a vector space... To assign an object to a
variable one uses the operator \lstinline{:=} as the following example shows:
\begin{lstlisting}
gap> p := 32;;
gap> p;
32
gap> p = 32;
true
gap> p := p+1;;
gap> p;
33
gap> p = 32;
false
\end{lstlisting}

\begin{remark}
  The symbols \lstinline{=} (conditional) and \lstinline{:=} (assignment
  operator) are different!
\end{remark}

\begin{remark}
What if I forgot to assign the result of a calculation for further use? We
can do the following:
\begin{lstlisting}
gap> 2*(5+1)-6;                                                       
6
gap> n := last;
6
\end{lstlisting}
One also has \lstinline{last2} and \lstinline{last3}. 
\end{remark}

\subsection*{Conditionals}

There are three very important operators: \lstinline{not}, \lstinline{and},
\lstinline{or}.  We also have comparison operators; for example the expression
\lstinline{x<>y} returns \lstinline{true} if \lstinline{x} and \lstinline{y}
are different, and \lstinline{false} otherwise.  Here we have
some easy examples: 
\begin{lstlisting}
gap> x := 20;; y := 10;;
gap> x <> y;
true
gap> x > y;
true
gap> (x > 0) or (x < y);
true
gap> (x > 0) and (x < y);
false
gap> (2*y < x);
false
gap> (2*y <= x);
true
gap> not (x < y);
true	
\end{lstlisting}

\begin{example}
	Let us check that $100^{300}>300^{100}$:
\begin{lstlisting}
gap> 100^300 > 300^100;
true
\end{lstlisting}
\end{example}

%%\begin{block}
%%\label{block:condicional}
%\begin{example}
%	Let us write the following 
%	\[
%	\begin{cases}
%		n^3 & \text{si $n\equiv0\bmod 3$},\\
%		n^5 & \text{si $n\equiv1\bmod 3$},\\
%		0 & \text{en otro caso}.
%	\end{cases}
%\]
%\end{example}
%%Los condicionales se utilizan para realizar distintas acciones dependiendo de
%%si ciertas condiciones se satisfacen o no.  En el siguiente ejemplo el valor de
%%un entero $n$ dado se modifica de acuerdo a la siguiente fórmula:
%%\[
%%	\begin{cases}
%%		n^3 & \text{si $n\equiv0\bmod 3$},\\
%%		n^5 & \text{si $n\equiv1\bmod 3$},\\
%%		0 & \text{en otro caso}.
%%	\end{cases}
%%\]
%%Veamos el código aplicado al número $n=10$:
%%\begin{lstlisting}
%%gap> n := 10;;
%%gap> if n mod 3 = 0 then
%%> n := n^3;
%%> elif n mod 3 = 1 then
%%> n := n^5;
%%> else
%%> n := 0;
%%> fi;
%%gap> n;
%%100000
%%\end{lstlisting}
%%Más ejemplos sobre condicionales aparecerán en la sección siguiente, donde
%%veremos cómo definir funciones.
%%\end{block}

\subsection*{Functions}

There are two equivalent ways of constructing functions. For example, to
construct the map $x\mapsto x^2$ either we can use the {\it one-line definition}
\begin{lstlisting}
gap> square := x->x^2;
function( x ) ... end
\end{lstlisting}
or the {\it classical}
\begin{lstlisting}
gap> square := function(x)
> return x^2;
> end;
function( x ) ... end
\end{lstlisting}
In both cases we will obtain the same result; with any definition:
\begin{lstlisting}
gap> square(4);
16
gap> square(-4);
16
gap> square(-5);
25
\end{lstlisting}
One can also define functions with no arguments. A classical example is:
\begin{lstlisting}
gap> hi := function()
> Display("Hello world");
> end;
function(  ) ... end
gap> hi();
Hello world
\end{lstlisting}

\begin{example}
Let us write a function to compute the map 
\[
f\colon n\mapsto\begin{cases}
	n^3 & \text{si $n\equiv0\bmod 3$},\\
	n^5 & \text{si $n\equiv1\bmod 3$},\\
	0 & \text{otherwise}.
\end{cases}
\]
Here is the code and some experiments:
\begin{lstlisting}
gap> f := function(n)
> if n mod 3 = 0 then
> return n^3;
> elif n mod 3 = 1 then
> return n^5;
> else
> return 0;
> fi;
> end;
function( n ) ... end
gap> f(10);
100000
gap> f(5);
0
gap> f(4);
1024
\end{lstlisting}
\end{example}

\begin{example}
\label{exa:Fibonacci:1}
\index{Fibonacci sequence}
The Fibonacci sequence $f_n$ is defined recursively as $f_1=f_2=1$ and 
\[
f_{n+1}=f_n+f_{n-1}
\]
for $n\geq2$. The following function computes Fibonacci numbers:
\begin{lstlisting}
gap> fibonacci := function(n)
> if n = 1 or n = 2 then
> return 1;
> else
> return fibonacci(n-1)+fibonacci(n-2);
> fi;
> end;
function( n ) ... end
gap> fibonacci(10);
55
\end{lstlisting}
Question: Can you compute $f_{100}$ with this method?
\end{example}

\begin{example}[Collatz conjecture]
	\index{Collatz!conjecture}
	\label{example:Collatz}
	For $n\in\N$ let 
	\[
		f(n)=\begin{cases}
			n/2 & \text{if $n$ es even},\\
			3n+1 & \text{if $n$ is odd}.
		\end{cases}
	\]
	The conjecture is that no matter what number $n$ you start with, there is
	$m\in\N$ such that $f^m(n)=1$, where $f^m=f\circ\cdots\circ f$ ($m$-times).
	Let us test the conjecture for $n=5$:
\begin{lstlisting}
gap> f := function(n)
> if n mod 2 = 0 then
> return n/2;
> else 
> return 3*n+1;
> fi;
> end;
function( n ) ... end
gap> f(f(f(f(f(5)))));
1
\end{lstlisting}
Exercise: Write a function that for each $n$ returns the smallest integer $m$ such that $f^m(n)=1$.

\medskip
A possible solution uses recursive functions:
\begin{lstlisting}
gap> g:=function(n)
> if f(n)=1 then
> return 1;
> else
> return 1+g(f(n));
> fi;
> end;
function( n ) ... end
\end{lstlisting}

A different approach, which uses ideas we will develop on page
\pageref{page:do}, can be given as follows:
\begin{lstlisting}
gap> g:=function(n)
> m:=1;
> while f(n)>1 do
> m:=m+1;
> n:=f(n);
> od;
> return m;
> end;
> function( n ) ... end
\end{lstlisting}
\end{example}



\subsection*{Strings}

A string is an expression delimited by the symbol 
\lstinline{"} (quotation mark): 
\begin{lstlisting}
gap> string := "hello world";
hello world
\end{lstlisting}
To extract one character one uses the expression \lstinline{string[position]};
to extract substrings \lstinline|string{positions}|. Examples:
\begin{lstlisting}
gap> string[1];
'h'
gap> string[3];
'l'
gap> string{[1,2,3,4,5]};
"hello"
gap> string{[7,8,9,10,11]};
"world"
gap> string{[11,10,9,8,7,6,5,4,3,2,1]};
"dlrow olleh"
\end{lstlisting}

There are several functions that allow us to work with strings.
\lstinline{String} converts anything into a string of characters.
\begin{lstlisting}
gap> String(1234);
"1234"
gap> String(01234);
"1234"
gap> String([1,2,3]);
"[ 1, 2, 3 ]"
gap> String(true);
"true"
\end{lstlisting}
%%La funcion \lstinline{LowercaseString} (resp. \lstinline{UppercaseString})
%%devuelve una cadena de caracteres que resulta de convertir el argumento a
%%minúsculas (resp. mayúsculas). Por ejemplo:
%%\begin{lstlisting}
%%gap> LowercaseString("Hola Mundo");
%%"hola mundo"
%%gap> UppercaseString("Hola Mundo");
%%"HOLA MUNDO"
%%\end{lstlisting}
%La función 
The function \lstinline{ReplacedString} replace substrings: 
\begin{lstlisting}
gap> ReplacedString("Hello world", "world", "all");
"Hello all"
\end{lstlisting}

\lstinline{Print} allows us to print data in the screen. 
\begin{lstlisting}
gap> string := "Hello world";;
gap> Print(string);
Hello world
\end{lstlisting}
Let us see another example:
\begin{lstlisting}
gap> n := 100;;                                                       
gap> m := 5;;
gap> Print(n, " times ", m, " is ", n*m);
100 times 5 is 500
\end{lstlisting}
The function \lstinline{Print} can be used with some special characters. For example, 
\lstinline{\n} means ``new line''. Examples:
\begin{lstlisting}
gap> Print("Hello\nworld");
Hello
world
gap> Print("To write \\...");
To write \... 
\end{lstlisting}
The functions \lstinline{PrintTo} and \lstinline{AppendTo} work as \lstinline{Print} but the output goes
to a file. It is important to remark that \lstinline{PrintTo} will overwrite an existing file!
%% JoinStringsWithSeparator
%% SplitString

\subsection*{Lists}

A list is an ordered sequence of objects (maybe of different type), including
empty places. Lists are written using square brackets. Examples:
\begin{lstlisting}
gap> IsList([1, 2, 3]);
true
gap> IsList([1, 2, 3, "abc"]);
true
gap> IsList([1, 2,, "abc"]);
true
gap> 2 in [1, 2, 5, 4, 10];
true
gap> 3 in [0,10,"abc"];
false
\end{lstlisting}

\begin{example}
Let us create a list with the first six prime numbers. \lstinline{Size} or
\lstinline{Length} return the number of non-empty elements of the list. 
\begin{lstlisting}
gap> primes := [2, 3, 5, 7, 11, 13];
[ 2, 3, 5, 7, 11, 13 ]
gap> Size(primes);
6
\end{lstlisting}
To access to an element inside a list one should refer to the position. 
\begin{lstlisting}
gap> primes[1];
2
gap> primes[2];
3
\end{lstlisting}
Let us obtain the sublist consisting of the elements in the second, third and
fifth position:
\begin{lstlisting}
gap> primes;
[ 2, 3, 5, 7, 11, 13 ]
gap> primes{[2,3,5]};
[ 3, 5, 11 ]
\end{lstlisting}
Another example (to avoid confusion):
\begin{lstlisting}
gap> list := ["a", "b", "c", "d", "e", "f"];
[ "a", "b", "c", "d", "e", "f" ]
gap> list{[1,3,5]};
[ "a", "c", "e" ]
\end{lstlisting}
To find elements inside a list one uses \lstinline{Position}. If the element we
are looking for does not belong to the list, \lstinline{Position} will return
\lstinline{fail}; otherwise it will return the first place where the element
appears. Let us look at some examples:
\begin{lstlisting}
gap> Position([5, 4, 6, 3, 7, 3, 7], 5);
1
gap> Position([5, 4, 6, 3, 7, 3, 7], 1);
fail
gap> Position([5, 4, 6, 3, 7, 3, 7], 7);
5
\end{lstlisting}

\lstinline{Add} and \lstinline{Append} are used to add elements at the end of a
list. To remove elements from a list one uses \lstinline{Remove}; examples:
\begin{lstlisting}
gap> primes;
[ 2, 3, 5, 7, 11, 13 ]
gap> # Add 19 at the end of the list 
gap> Add(primes, 19);
gap> primes;
[ 2, 3, 5, 7, 11, 13, 19 ]
gap> # Add the prime 17 at position 7
gap> Add(primes, 17, 7); 
gap> primes;
[ 2, 3, 5, 7, 11, 13, 17, 19 ]
gap> # Add 23 and 29 at the end
gap> Append(primes, [23, 29]);
gap> primes;
[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ]
gap> # Remove the first element of the list
gap> Remove(primes, 1);;
gap> primes;
[ 3, 5, 7, 11, 13, 17, 19, 23, 29 ]
\end{lstlisting}
\end{example}

\lstinline{Concatenation} concatenates two or more lists. This function returns a new list 
consisting of the lists used in the argument. 
\begin{lstlisting}
gap> Concatenation([1,2,3],[4,5,6]);
[ 1, 2, 3, 4, 5, 6 ]
\end{lstlisting}

\begin{remark}
  Is there any difference between \lstinline{Append} and
  \lstinline{Concatenation}? Yes!  The function \lstinline{Concatenation} does
  not modify the lists used in the argument. \lstinline{Append} does.
\end{remark}

%A diferencia de \lstinline{Append}, la función \lstinline{Concatenation} no
%modifica las listas que se utilizan como argumento. 

\lstinline{Collected} returns a new list where each element 
of the original list appears with multiplicity. 
Example: 
\begin{lstlisting}
gap> Factors(720);
[ 2, 2, 2, 2, 3, 3, 5 ]
gap> Collected(last);
[ [ 2, 4 ], [ 3, 2 ], [ 5, 1 ] ]
\end{lstlisting}

To make a copy of a list one should use the function \lstinline{ShallowCopy}.
The following example shows the difference between \lstinline{ShallowCopy} and
the assignment operator. 
\begin{lstlisting}
gap> a := [1, 2, 3, 4];;
gap> b := a;;
gap> c := ShallowCopy(a);;
gap> Add(a, 5);
gap> a;
[ 1, 2, 3, 4, 5 ]
gap> b;
[ 1, 2, 3, 4, 5 ]
gap> c;
[ 1, 2, 3, 4 ]
gap> Add(b, 10);
gap> a;
[ 1, 2, 3, 4, 5, 10 ]
gap> b;
[ 1, 2, 3, 4, 5, 10 ]
\end{lstlisting}

The function \lstinline{Reversed} returns a list
containing the elements of our list in reversed order. 
In the following example 
the variable \lstinline{list} will not be modified by the function \lstinline{Reversed}:
%devuelve una lista que se obtiene al invertir
%el orden de los elementos de la lista que se envía como argumento. En el
%ejemplo siguiente observamos que \lstinline{list} no se
%modifica con la función \lstinline{Reversed}:
\begin{lstlisting}
gap> list := [2, 4, 7, 3];;
gap> Reversed(list);
[ 3, 7, 4, 2 ]
gap> list;
[ 2, 4, 7, 3 ]
\end{lstlisting}
\lstinline{SortedList} returns a new list where the elements are sorted with
respect to the operator \lstinline{<=}. In the following example one sees that
\lstinline{SortedList} will not modify the value of the variable
\lstinline{list}:
\begin{lstlisting}
gap> list := [2, 4, 7, 3];;
gap> SortedList(list);
[ 2, 3, 4, 7 ]
gap> list;
[ 2, 4, 7, 3 ]
\end{lstlisting}
\lstinline{Sort} sorts a list in increasing order. Can you recognize the
difference between \lstinline{Sort} and \lstinline{SortedList}?
\begin{lstlisting}
gap> list := [2, 4, 7, 3];;
gap> Sort(list);
gap> list;
[ 2, 3, 4, 7 ]
\end{lstlisting}

\begin{remark}
  Say that we want to apply \lstinline{SortedList} or \lstinline{Sort} to a
  given list. In this case, all the elements of the list must be of the same
  type and comparable with respect to the operator \lstinline{<=}. 
\end{remark}

\lstinline{Filtered} allows us to obtain the elements of a list that satisfy a
particular given property.  The function \lstinline{Number} returns the number
of elements of a list  that satisfy a given property.  \lstinline{First}
returns the first element of a list that satisfy a given property. Some examples are as follows:
\begin{lstlisting}
gap> list := [1, 2, 3, 4, 5];;
gap> Filtered(list, x->x mod 2 = 0);
[ 2, 4 ]
gap> Number(list, x->x mod 2 = 0);
2
gap> Filtered(list, x->x mod 2 = 1);
[ 1, 3, 5 ]
gap> First(list, x->x mod 2 = 0);
2
\end{lstlisting}

\begin{example}
Let us compute how many powers of 2 divide 18000. This number is four, as
the following code shows:
\begin{lstlisting}
gap> Factors(18000);
[ 2, 2, 2, 2, 3, 3, 5, 5, 5 ]
gap> Collected(Factors(18000));
[ [ 2, 4 ], [ 3, 2 ], [ 5, 3 ] ]
gap> Number(Factors(18000), x->x=2);
4
\end{lstlisting}
\end{example}

There are very nice ways to create lists. The following examples need no
further explanations.
\begin{lstlisting}
gap> List([1, 2, 3, 4, 5], x->x^2);
[ 1, 4, 9, 16, 25 ]
gap> List([1, 2, 3, 4, 5], IsPrime);
[ false, true, true, false, true ]
\end{lstlisting}

\subsection*{Ranges} 

Ranges are lists where the difference between two
consecutive integers is a constant.  Examples:
\begin{lstlisting}
gap> Elements([1,3..11]);
[ 1, 3, 5, 7, 9, 11 ]
gap> Elements([1..5]);
[ 1, 2, 3, 4, 5 ]
gap> Elements([0,-2..-8]);
[ -8, -6, -4, -2, 0 ]
gap> IsRange([1..100]);
true
gap> IsRange([1,3,5,6]);
false
\end{lstlisting}

We can use \lstinline{Elements} to list all the elements in a given range.
Conversely, \lstinline{ConvertToRangeRep} converts (if possible) a list into a
range.  Examples:
\begin{lstlisting}
gap> list := [ 1, 2, 3, 4, 5 ];;
gap> ConvertToRangeRep(list);;
gap> list;
[ 1 .. 5 ]
gap> list := [ 7, 11, 15, 19, 23 ];
gap> IsRange(list);
true
gap> ConvertToRangeRep(list);
gap> list;
[ 7, 11 .. 23 ]
\end{lstlisting}

\subsection*{Sets} 

A set is a particular type of ordered list that contains no gaps with no
repetitions.  To convert a list to a set one uses \lstinline{Set}.  
\begin{lstlisting}
gap> list := [1, 2, 3, 1, 5, 6, 2];;
gap> IsSet(list);
false
gap> Set(list);
[ 1, 2, 3, 5, 6 ]
\end{lstlisting}

To add elements use 
\lstinline{AddSet} and \lstinline{UniteSet}. To remove them, 
\lstinline{RemoveSet}. Examples:
\begin{lstlisting}
gap> set := Set([1, 2, 4, 5]);;
gap> # Let us add the number 10 
gap> AddSet(set, 10);
gap> set;
[ 1, 2, 4, 5, 10 ]
gap> # Let us remove the number 4 
gap> RemoveSet(set, 4);
gap> set;
[ 1, 2, 5, 10 ]
gap> UniteSet(set, [1, 1, 5, 6]);
gap> set;
[ 1, 2, 5, 6, 10 ]
\end{lstlisting}
To perform basic set operations one uses
\lstinline{Union}, \lstinline{Intersection},
\lstinline{Difference} and \lstinline{Cartesian}. Examples: 
\begin{lstlisting}
gap> S := Set([1, 2, 8, 11]);;
gap> T := Set([2, 5, 7, 8]);;
gap> Intersection(S, T);
[ 2, 8 ]
gap> Union(S, T);
[ 1, 2, 5, 7, 8, 11 ]
gap> Difference(S, T);
[ 1, 11 ]
gap> Difference(T, S);
[ 5, 7 ]
gap> Difference(S, S);
[  ]
gap> Cartesian(S, T);
[ [ 1, 2 ], [ 1, 5 ], [ 1, 7 ], [ 1, 8 ], [ 2, 2 ], 
  [ 2, 5 ], [ 2, 7 ], [ 2, 8 ], [ 8, 2 ], [ 8, 5 ], 
  [ 8, 7 ], [ 8, 8 ], [ 11, 2 ], [ 11, 5 ], 
  [ 11, 7 ], [ 11, 8 ] ]
\end{lstlisting}

\subsection*{Records}

Records allow us to put several objects in the same structure. Let us say that
we want to create a structure for the point $(1,2)$ of the plane: 
\begin{lstlisting}
gap> point := rec(x := 1, y := 2);;
gap> point.x;
1
gap> point.y;
2
gap> RecNames( point );
[ "x", "y" ]
\end{lstlisting}
%%En el ejemplo siguiente vamos a utilizar \lstinline{RecNames} para sumar uno en
%%cada componente del registro \lstinline{point} que creamos antes:
%%\begin{lstlisting}
%%gap> point := rec( x := 1, y := 2 );;
%%gap> for r in RecNames(point) do
%%> point.(r) := point.(r) + 1;
%%> od;
%%gap> point;
%%rec( x := 2, y := 3 )
%%\end{lstlisting}
%Puede utilizarse la función 
The function \lstinline{IsBound} can be used to test whether our structure
contains a given component.  The function \lstinline{Unbind} removes a variable
from the memory. Examples:
\begin{lstlisting}
gap> point := rec( x := 1, y := 2 );;
gap> IsBound(point.z);
false
gap> point.z := 3;;
gap> IsBound(point.z);
true
gap> point;
rec( x := 1, y := 2, z := 3 )
gap> Unbind(point.z);
gap> point;
rec( x := 1, y := 2 )
\end{lstlisting}
%%FIXME: Isbind

\subsection*{Loops}
\label{page:do}
Our section of loops will be based on the following very simple problem.  We
want to check that 
\[
    1+2+3+\cdots+100=5050.
\]

Of course we can use \lstinline{Sum}, which sums all the elements of a list:
\begin{lstlisting}
gap> Sum([1..100]);
5050
\end{lstlisting}
An equivalent way of doing this would be using \lstinline{for ... do ... od}:
\begin{lstlisting}
gap> s := 0;;
gap> for k in [1..100] do
> s := s+k;
> od;
gap> s;
5050
\end{lstlisting}
Yet another equivalent way of doing this is the following:
\lstinline{while ... do ... od}:
\begin{lstlisting}
gap> s := 0;;
gap> k := 1;;
gap> while k<=100 do
> s := s+k;
> k := k+1;
> od;
gap> s;
5050
\end{lstlisting}
Yet another equivalent way of doing this is the following: 
\lstinline{repeat ... until}:
\begin{lstlisting}
gap> s := 0;;
gap> k := 1;;
gap> repeat
> s := s+k;
> k := k+1;
> until k>100;
gap> s;
5050
\end{lstlisting}

Now let us compute (again) Fibonacci numbers. This is better than the method of
Example~\ref{exa:Fibonacci:1}. 

\begin{example}
\label{exa:Fibonacci:2}
\index{Fibonacci sequence}
Let us write a non-recursive function to compute Fibonacci numbers. 
\begin{lstlisting}
gap> fibonacci := function(n)                                                 
> local k, x, y, tmp;
> x := 1;
> y := 1;
> for k in [3..n] do
>   tmp := y;
>   y := x+y;
>   x := tmp;
> od; 
> return y;
> end;
function( n ) ... end
gap> fibonacci(100);
354224848179261915075
gap> fibonacci(1000);
434665576869374564356885276750406258025646605173\
717804024817290895365554179490518904038798400792\
551692959225930803226347752096896232398733224711\
616429964409065331879382989696499285160037044761\
37795166849228875
\end{lstlisting}
\end{example}

\begin{example}
\label{exa:100}
Divisors of a given integer can be obtained with \lstinline{DivisorsInt}.  In this
example we run over the divisors of $100$ and print only those that are
odd.
\begin{lstlisting}
gap> Filtered(DivisorsInt(100), x->x mod 2 = 1);
[ 1, 5, 25 ]
\end{lstlisting}
Similarly 
\begin{lstlisting}
gap> for d in DivisorsInt(100) do
> if d mod 2 = 1 then
> Display(d);
> fi;
> od;
1
5
25
\end{lstlisting}
With \lstinline{continue} one can skip iterations. An equivalent (but less
elegant) approach to the problem of Example~\ref{exa:100} is the following:
\begin{lstlisting}
gap> for d in DivisorsInt(100) do
> if d mod 2 = 0 then
> continue;
> fi;
> Display(d);
> od;
1
5
25
\end{lstlisting}
\end{example}

With \lstinline{break} one breaks a loop. In the following example we run over
the numbers $1,2,\dots,100$ and stop when a number whose square is divisible by
$20$ appears. 
\begin{lstlisting}
gap> First([1..100], x->x^2 mod 20 = 0);
10
\end{lstlisting}
Similarly:
\begin{lstlisting}
gap> for k in [1..100] do
> if k^2 mod 20 = 0 then
> Display(k);
> break;
> fi;
> od;
10
\end{lstlisting}

\lstinline{ForAny} returns \lstinline{true} if there is an element in the list 
satisfying the required condition and 
\lstinline{false} otherwise. 
Similarly 
\lstinline{ForAll} returns \lstinline{true} if all the
elements of the list satisfy the required condition and 
\lstinline{false} otherwise. Examples:
\begin{lstlisting}
gap> ForAny([2,4,6,8,10], x->x mod 2 = 0);
true
gap> ForAll([2,4,6,8,10], x->(x > 0));
true
gap> ForAny([2,3,4,5], IsPrime);
true
gap> ForAll([2,3,4,5], IsPrime);
false
\end{lstlisting}

\section{Permutations}
\label{permutations}
\index{Permutation}

Let $n\in\N$. A \textbf{permutation} in $n$ letters is a bijective map
$\sigma\colon\{1,\dots,n\}\to\{1,\dots,n\}$. For example, the permutation
$\binom{1234}{3124}$ is the bijective map $1\mapsto 3$, $2\mapsto 1$,
$3\mapsto 2$ and $4\mapsto 4$. 
%Let $\Sym_n$ be the set of permutations $\sigma\colon\{1,\dots,n\}\to\{1,\dots,n\}$.
Usually one writes a permutation as a product of disjoint cycles. For example:
\begin{align*}
&\binom{1234}{2413}=(1243),
&&\binom{12345}{21435}=(12)(34)(5)=(12)(34).
\end{align*}
The permutation $\binom{12345}{21435}=(12)(34)$ in~\GAP~is 
\lstinline{(1,2)(3,4)}.  The function \lstinline{IsPerm} checks whether 
some object is a permutation. Let us see some examples:
\begin{lstlisting}
gap> IsPerm((1,2)(3,4));
true
gap> (1,2)(3,4)(5)=(1,2)(3,4);
true
gap> (1,2)(3,4)=(3,4)(2,1);
true
gap> IsPerm(25);
false
gap> IsPerm([1,2,3,4]);
false
\end{lstlisting}

%The natural action of a permutation $\sigma$ on $\{1,\dots,n\}$ is a right action!

The image of an element \lstinline{i} under the natural right action of a
permutation \lstinline{p} is \lstinline{i^p}. The preimage of the element
\lstinline{i} under \lstinline{p} can be obtained with \lstinline{i/p}. In the
following example we compute the image of $1$ and the preimage of $3$ by the
permutation $(123)$: 
\begin{lstlisting}
gap> 2^(1,2,3);
3
gap> 2/(1,2,3);
1
\end{lstlisting}
Composition of permutations will be performed from left to right. For example
\[
  (123)(234)=(13)(24)
\]
as the following code shows: 
\begin{lstlisting}
gap> (1,2,3) * (2,3,4);
(1,3)(2,4)
\end{lstlisting}
To obtain the inverse of a permutation one uses 
\lstinline{Inverse}: 
\begin{lstlisting}
gap> Inverse((1,2,3));
(1,3,2)
gap> (1,2,3)^(-1);
(1,3,2)
\end{lstlisting}

Let $\sigma$ be a permutation written as a product of disjoint cycles.  The
function \lstinline{ListPerm} returns a list containing $\sigma(i)$ at position
$i$.  Conversely, any list of this type can be transformed into a permutation
with the function
\lstinline{PermList}. Examples:
\begin{lstlisting}
gap> # The permutation (12) in two letters
gap> ListPerm((1,2));                                                 
[ 2, 1 ]
gap> # The permutation (12) in four letters
gap> ListPerm((1,2), 4);
[ 2, 1, 3, 4 ]
gap> ListPerm((1,2,3)(4,5));
[ 2, 3, 1, 5, 4 ]
gap> ListPerm((1,3));
[ 3, 2, 1 ]
gap> PermList([1,2,3]);
()
gap> PermList([2,1]);
(1,2)
\end{lstlisting}

\index{Permutation!sign of a}
The \textbf{sign} of a permutation $\sigma$ is the number $(-1)^k$, where
$\sigma=\tau_1\cdots\tau_k$ is some factorization of $\sigma$ as a product of
transpositions. To compute the sign of a permutation one uses the function
\lstinline{SignPerm}. Examples:
\begin{lstlisting}
gap> SignPerm(());                                                    
1
gap> SignPerm((1,2));
-1
gap> SignPerm((1,2,3,4,5));
1
gap> SignPerm((1,2)(3,4,5));
-1
gap> SignPerm((1,2)(3,4));
1
\end{lstlisting}
% sopore,puntosquesemueven,puntosfijos

\begin{example}
For a given $n$ we will construct the permutation $\sigma\in\Sym_n$ given by
$\sigma(j)=n-j+1$, we will write $\sigma$ as a product of disjoint cycles and
we will compute its sign:
\begin{lstlisting}
gap> n := 5;;
gap> p := PermList(List([1..n], j->n-j+1));
(1,5)(2,4)
gap> SignPerm(p);
1
\end{lstlisting}
\end{example}

\section{Matrices}
\label{matrices}

\index{Matrix!number of rows}
\index{Matrix!number of columns}
For us a matrix will be just a rectangular array of numbers.  The size of a
matrix can be obtained with \lstinline{DimensionsMat}.  Sometimes (for example
if one has an integer matrix) the function \lstinline{Display} shows matrices
in a nice way.  \lstinline{LaTeX} returns the \LaTeX~command\footnote{The
function \lstinline{LaTeX} works for other \GAP~objects as well.} needed to
write a matrix. 
Examples:
\begin{lstlisting}
gap> m := [[1,2,3],[4,5,6]];;                                         
gap> Display(m);
[ [  1,  2,  3 ],
  [  4,  5,  6 ] ]
gap> LaTeX(m);
"\\left(\\begin{array}{rrr}%\n1&2&3\\
\\%\n4&5&6\\\\%\n\\end{array}\\right)%\n"
gap> m[1][1];
1
gap> m[1][2];
2
gap> m[2][1];
4
gap> DimensionsMat(m);
[ 2, 3 ]
\end{lstlisting}

Let us play with row vectors:

\index{Vectors!basic operations}
\begin{example}
Let $v=(1,2,3)$ and $w=(0,5,-7)$ be row vectors of $\Q^3$. 
Let us check that $-5v=(-5,-10,-15)$ and $2v-w=(2,-1,13)$. We also check that the inner product between $v$ and $w$ is $v\cdot w=-11$. 
\begin{lstlisting}
gap> v := [1,2,3];;
gap> w := [0,5,-7];;
gap> IsRowVector(v);
true
gap> IsRowVector(w);
true
gap> -5*v;
[ -5, -10, -15 ]
gap> 2*v-w;
[ 2, -1, 13 ]
gap> v*w;
-11
\end{lstlisting}
\end{example}

We now perform some elementary calculations with matrices: 

\index{Matrix!basic operations}
\begin{example}
Let 
\[
A=\begin{pmatrix}
    1 & 1 & 1\\
    0 & 1 & 1\\
    0 & 0 & 1
\end{pmatrix},
\quad
B=\begin{pmatrix}
    1 & 4 & 7\\
    2 & 5 & 8\\
\end{pmatrix},
\quad
C=\begin{pmatrix}
    1 & 2\\
    6 & 1\\
    0 & 2
\end{pmatrix}.
\]
Let us compute $A^3$, $BC$, $CB$, $A+CB$ and $2A-5CB$: 
\begin{lstlisting}
gap> A := [[1,1,1],[0,1,1],[0,0,1]];;
gap> B := [[1,4,7],[2,5,8]];;
gap> C := [[1,2],[6,1],[0,2]];;
gap> Display(A^3);
[ [  1,  3,  6 ],
  [  0,  1,  3 ],
  [  0,  0,  1 ] ]
gap> Display(B*C);
[ [  25,  20 ],
  [  32,  25 ] ]
gap> Display(C*B);
[ [   5,  14,  23 ],
  [   8,  29,  50 ],
  [   4,  10,  16 ] ]
gap> Display(A+C*B);
[ [   6,  15,  24 ],
  [   8,  30,  51 ],
  [   4,  10,  17 ] ]
gap> Display(2*A-5*C*B);
[ [   -23,   -68,  -113 ],
  [   -40,  -143,  -248 ],
  [   -20,   -50,   -78 ] ]
\end{lstlisting}
\end{example}

\index{Matrix!diagonal}
\index{Matrix!null}
\index{Matrix!diagonal}
To construct a null matrix one uses the function \lstinline{NullMat}. The
identity is constructed with the function \lstinline{IdentityMat}. To construct
diagonal matrices one uses \lstinline{DiagonalMat}. Examples:
\begin{lstlisting}
gap> Display(NullMat(2,3));
[ [  0,  0,  0 ],
  [  0,  0,  0 ] ]
gap> Display(IdentityMat(3));
[ [  1,  0,  0 ],
  [  0,  1,  0 ],
  [  0,  0,  1 ] ]
gap> Display(DiagonalMat([1,2]));
[ [  1,  0 ],
  [  0,  2 ] ]
\end{lstlisting}

\index{Matrix!submatrices of a}
We know that \lstinline{matrix[i][j]} returns the $(i,j)$-element of our matrix. 
To extract submatrices from a matrix one uses 
\lstinline|matrix{rows}{columns}| such as the following example shows:
\begin{lstlisting}
gap> m := [\
> [1, 2, 3, 4, 5],\
> [6, 7, 8, 9, 3],\
> [3, 2, 1, 2, 4],\
> [7, 5, 3, 0, 0],\
> [0, 0, 0, 0, 1]];
gap> m{[1..3]}{[1..3]};
[ [ 1, 2, 3 ], [ 6, 7, 8 ], [ 3, 2, 1 ] ]
gap> m{[2,4,5]}{[1,3]};
[ [ 6, 8 ], [ 7, 3 ], [ 0, 0 ] ]
\end{lstlisting}

\index{Matrix!over a finite field}
It is possible to work with matrices with coefficients in arbitrary rings. Let
us start working with matrices over the finite field $\F_5$ of five elements:
\begin{lstlisting}
gap> m := [[1,2,3],[3,2,1],[0,0,2]]*One(GF(5));
[ [ Z(5)^0, Z(5), Z(5)^3 ], 
  [ Z(5)^3, Z(5), Z(5)^0 ], 
  [ 0*Z(5), 0*Z(5), Z(5) ] ]
gap> Display(m);
 1 2 3
 3 2 1
 . . 2
\end{lstlisting}
Now let us work with $3\times 3$ matrices with coefficients 
in the ring $\Z/4$. Let us compute the identity of $M_3(\Z/4)$:
\begin{lstlisting}
gap> m := IdentityMat(3, ZmodnZ(4));;
gap> Display(m);
matrix over Integers mod 4:
[ [  1,  0,  0 ],
  [  0,  1,  0 ],
  [  0,  0,  1 ] ]
\end{lstlisting}

One uses the function \lstinline{Inverse} to compute the inverse of an
invertible (square) matrix.  
This function returns \lstinline{fail} if the matrix is not invertible. 
\lstinline{IsIdentityMat} returns either
\lstinline{true} if the argument is the identity matrix or \lstinline{false}
otherwise.  We also use \lstinline{TransposedMat} to compute the transpose of a
matrix:
\begin{lstlisting}
gap> m := [[1, -2, -1], [0, 1, 0], [1, -1, 0]];;
gap> Display(Inverse(m));
[ [   0,   1,   1 ],
  [   0,   1,   0 ],
  [  -1,  -1,   1 ] ]
gap> Inverse([[1,0],[2,0]]);
fail
gap> IsIdentityMat(m*Inverse(m));
true 
gap> Display(TransposedMat(m)*m);
[ [   2,  -3,  -1 ],
  [  -3,   6,   2 ],
  [  -1,   2,   1 ] ]
\end{lstlisting}	

Creating random matrices is easy.  \lstinline{RandomMat} returns a random
rectangular matrix over a given ring, which defaults to $\Z$. With
\lstinline{RandomInvertibleMat} (resp. with \lstinline{RandomUnimodularMat})
one creates a random square matrix with integer entries invertible (resp. over
the integers).
\begin{lstlisting}
gap> RandomMat(2,2);
[ [ 2, 0 ], [ 4, -1 ] ]
gap> RandomInvertibleMat(2);
[ [ 1, -2 ], [ -1, 0 ] ]
gap> Inverse(last);
[ [ 0, -1 ], [ -1/2, -1/2 ] ]
gap> RandomUnimodularMat(3);
[ [ 5, -15, 28 ], [ -2, 6, -11 ], [ -11, 32, -60 ] ]
gap> Inverse(last);
[ [ -8, -4, -3 ], [ 1, 8, -1 ], [ 2, 5, 0 ] ]
\end{lstlisting}

\begin{example}
  \index{Fibonacci sequence}
An easy induction exercise shows that the Fibonacci sequence $(f_n)$ 
can be computed using 
\[
    \begin{pmatrix}
        0 & 1\\
        1 & 1
    \end{pmatrix}^n=\begin{pmatrix}
        f_{n-1} & f_n\\
        f_n & f_{n+1}
    \end{pmatrix},\quad n\geq1. 
\]
We use this trick to compute (very efficiently) Fibonacci numbers: 
\begin{lstlisting}
gap> fibonacci := function(n)
> local m;
> m := [[0,1],[1,1]]^n;;
> return m[1][2];
> end;
function( n ) ... end
gap> fibonacci(10);
55
gap> fibonacci(100000);
<integer 259...875 (20899 digits)>
\end{lstlisting}
\end{example}

One can easily compute the characteristic and minimal polynomial of a matrix
with \lstinline{CharacteristicPolynomial} and \lstinline{Minimal Polynomial},
respectively.

Let $A$ be an $m\times n$ and let $b$ be an $1\times n$ matrix (say, a row
vector of length $n$).  \lstinline{SolutionMat} returns (if possible) some $x$
of size $1\times m$ such that $xA=b$. In case there is no $x$ such that $xA=b$,
the function returns  \lstinline{fail}. Let us see some examples:
\begin{lstlisting}
gap> # Only one solution
gap> SolutionMat([[1,2],[3,4]], [13,2]);
[ -23, 12 ]
gap> # Infinite solutions
gap> SolutionMat([[1,2],[2,4]], [1,2]);
[ 1, 0 ]
gap> # No solutions
gap> SolutionMat([[1,2],[2,4]], [1,3]);
fail
\end{lstlisting}

\index{Matrix!trace of a}
\index{Matrix!determinant of a}
\index{Matrix!rank of a}
The trace of a square matrix is computed with \lstinline{Trace}. The
determinant with \lstinline{Determinant}. The rank of a matrix is computed with
\lstinline{Rank}. Examples:
\begin{lstlisting}
gap> m := [[1, 2, 3],[5, 4, 3],[0, 0, 2]];;
gap> Determinant(m);
-12
gap> Trace(m);
7
gap> Rank(m);
3
gap> Rank(NullMat(2, 2));
0
gap> Rank([[1, 2, 3],[4, 5, 6],[6, 7, 8]]);
2
gap> Rank([[1, 2, 3],[4, 5, 6],[6, 7, 9]]);
3
\end{lstlisting}
The function \lstinline{NullspaceMat} computes the vector space generated by
the solutions of $xA=0$, where $x$ is a matriz of size $1\times m$ and $A$ is a
matrix of size $m\times n$. 

\section{Polynomials}

One can define polynomial rings with \lstinline{PolynomialRing}. Indeterminates
are defined with \lstinline{IndeterminatesOfPolynomialRing}. As an example, we
define the polynomial $\Q[x]$ in one variable $x$ over the ring $\Q$s:
\begin{lstlisting}
gap> A := PolynomialRing(Rationals,["x"]);;
gap> x := IndeterminatesOfPolynomialRing(A)[1];
x
\end{lstlisting}

Let us see some operations on polynomials.  One uses the function
\lstinline{Value} to evaluate polynomials. With \lstinline{Factors} one obtains
the factorization of a polynomial over the default ring where the polynomial is
defined. \lstinline{RootsOfPolynomial} returns all the roots of the polynomial.
Here we have some examples:
\begin{lstlisting}
gap> x := Indeterminate(Rationals);;
gap> DefaultRing(x);
Rationals[x]
gap> IsPolynomial(x^2+x-2);
true
gap> IsPolynomial((x^2+x-2)/(x-1));
true
gap> AsPolynomial((x^2+x-2)/(x-1));
x+2
gap> Value(x^2+x-2, 0);
-2
gap> Value(x^2+x-2, 1);
0
gap> Value(x^2+x-2, -1);
-2
gap> Factors(x^2+x-2);
[ x-1, x+2 ]
gap> RootsOfPolynomial(x^2+x-2);
[ 1, -2 ]
\end{lstlisting}

The degree of a polynomial can be obtained with \lstinline{Degree}.  The
coefficients with the function \lstinline{CoefficientsOfUnivariatePolynomial}.
The example below needs no further explanation:
\begin{lstlisting}
gap> x := Indeterminate(Rationals);;
gap> f := x^5+2*x^3+3*x^2+4;;
gap> Degree(f);
5
gap> CoefficientsOfUnivariatePolynomial(f);
[ 4, 0, 3, 2, 0, 1 ]
gap> LeadingCoefficient(f);
1
\end{lstlisting}



\begin{example}
	Let $f=21x^2+9$ and $g=20x^4+10x$ be polynomials in $\Z/30[x]$. Let us
	check that $fg=0$:
\begin{lstlisting}
gap> x := Indeterminate(Integers mod 30);;
gap> f := 21*x^2+9;;
gap> g := 20*x^4+10*x;;
gap> f*g;
ZmodnZObj(0,30)
gap> IsZero(f*g);
true
\end{lstlisting}
\end{example}

\begin{example}
Let us check that $2x^2+1$ divides $6x^3+10x^2+3x+5$ in $\Q[x]$:
\begin{lstlisting}
gap> x := Indeterminate(Rationals);;
gap> (6*x^3+10*x^2+3*x+5) mod (2*x^2+1);
0
gap> (6*x^3+10*x^2+3*x+5)/(2*x^2+1);
3*x+5
\end{lstlisting}
\end{example}

\begin{example}
	Let us factorize in $\Q[x]$ the polynomial
	$f=2x^5+3x^4-x^2-2x+1$ and prove that 
	\[
	2x^5+3x^4-x^2-2x+1=(2x-1)(x^2+x-1)(x^2+x+1).
	\]
	Here is the code:
\begin{lstlisting}
gap> x := Indeterminate(Rationals);;
gap> Factors(2*x^5+3*x^4-x^2-2*x+1);
[ 2*x-1, x^2+x-1, x^2+x+1 ]
\end{lstlisting}
Now we see that a cubic root of one is a root of our $f$. Let us try to
factorize $f$ over $\Q(\omega)$, where $\omega$ is a cubic root of one:
\begin{lstlisting}
gap> Factors(PolynomialRing(Field(E(3)),"x"),\
> 2*x^5+3*x^4-x^2-2*x+1);
[ 2*x-1, x+(-E(3)), x+(-E(3)^2), x^2+x-1 ]
\end{lstlisting}
\end{example}

\begin{example}
	Let $f=x^2+5x+2$ and $g=x^4+1$. We check that $3f-2g$ is irreducible (over
	the integers): 
\begin{lstlisting}
gap> x:=Indeterminate(Integers,"x");;
gap> y:=Indeterminate(Integers,"y");;
gap> f := x^2+5*x+2;;
gap> g := x^4+1;;
gap> 3*f-2*g;
-2*x^4+3*x^2+15*x+4
gap> IsIrreducible(last);
true
\end{lstlisting}
\end{example}
%gap> x:=Indeterminate(Integers,"x");;
%gap> y:=Indeterminate(Integers,"y");;
%gap> f:=x*y+y+x^7;
%x^7+x*y+y
%gap> Value(f,[x,y],[5,7]);
%78167
\begin{example}
	\label{example:primes}
	The polynomial $x^2-x+41$ gives a prime for $x\in\{0,\dots,40\}$. Let us
	check this:
\begin{lstlisting}
gap> x := Indeterminate(Rationals);;
gap> p := x^2-x+41;;
gap> List([0..40], j->Value(p, j));
[ 41, 41, 43, 47, 53, 61, 71, 83, 97, 113, 131, 151, 
  173, 197, 223, 251, 281, 313, 347, 383, 421, 461, 
  503, 547, 593, 641, 691, 743, 797, 853, 911, 971, 
  1033, 1097, 1163, 1231, 1301, 1373, 1447, 1523, 
  1601 ]
gap> Filtered(last, j->not IsPrime(j));
[  ]
\end{lstlisting}
\end{example}


\section{Problems}

\begin{prob}
	\label{prob:chinese}
	Use \lstinline{ChineseRem} to find (if possible) the smallest solution of
	the following congruences:
	\[
		\begin{cases}
		x\equiv 3\bmod 10,\\
		x\equiv 8\bmod 15,\\
		x\equiv 5\bmod 84
	\end{cases}
	\quad
	\begin{cases}
		x\equiv 29\bmod 52,\\
		x\equiv 19\bmod 72.
	\end{cases}
	\]
\end{prob}

\begin{prob}
	\label{prob:gcd}
	Compute the $\gcd$ of $42823$ and $6409$. 
	Find $x,y\in\Z$ such that
	\[
	\gcd(5033464705,3138740337)=5033464705x+3138740337y. 
	\]
\end{prob}

\begin{prob}
	\label{prob:sequence}
	Describe the following sequence: $a_1=3$, $a_{n+1}=3^{a_n}\bmod 100$.
\end{prob}

\begin{prob}
	\label{prob:product}
    Use \lstinline{Product} to compute $2\cdot 4\cdot 6\cdots
    20$. 
\end{prob}

\begin{prob}
	\label{prob:2sums}
	Prove that
	\[
	1-\frac12+\frac13-\frac14+\cdots+\frac{1}{9999}-\frac{1}{10000}=
	\frac{1}{5001}+\frac{1}{5002}+\cdots+\frac{1}{10000}.
	\]
\end{prob}

\begin{prob}
	\label{prob:last2}
	Find the last two digits of $3^{400}$.
\end{prob}

\begin{prob}
	\label{prob:congruence}
	Find the roots of $x^2+x+7\equiv 0\bmod m$ for $m\in\{15,189\}$.
\end{prob}

\begin{prob}
	\label{prob:binary}
	Write a function that returns the binary expansion of an integer. Could you
	do this for other bases?
%FIXME
%    Escriba funciones que convierta números decimales a binarios y binarios a
%    decimales.
\end{prob}

\begin{prob}	\label{prob:minpoly}
	Use \lstinline{MinimalPolynomial} to compute the minimal polynomial of
	$3+\sqrt{5}$ over the rational numbers.
\end{prob}
%
\begin{prob}\label{prob:fibo100}
	Compute the first $100$ Fibonacci numbers.
\end{prob}

\begin{prob}\label{prob:fibok}
	For $k\in\N$ let $a_n$ be given by $a_1=\cdots=a_{k+1}=1$ and
	$a_n=a_{n-k}+a_{n-k-1}$ for all $n>k+1$. Write a function depending on $k$
	that constructs the sequence $a_{n}$.  For more information see 
	\url{http://oeis.org/A103379}.
\end{prob}

\begin{prob}[Somos sequence]\label{prob:somos}
	Write a function that returns the $n$-th term of $a_n$, where 
	$a_0=a_1=a_2=a_3=1$ and  
	\begin{align*}
	&a_n=\frac{a_{n-1}a_{n-3}+a_{n-2}^2}{a_{n-4}}
	\end{align*}
	for all $n\geq4$. For more information see \url{http://oeis.org/A006720}.
\end{prob}

\begin{prob}\label{prob:xwords}
	Write a function that given a list \lstinline{lst} of words and a letter
	\lstinline{x}, returns a sublist of \lstinline{lst} where every word starts
	with \lstinline{x}. 
\end{prob}

\begin{prob}\label{prob:number-primes}
	Write a function that returns the number of prime numbers $\leq n$. 
\end{prob}

\begin{prob}\label{prob:anagrams}
	Use the function~\lstinline{Permuted} to write a function that shows all
	the anagrams of a given word. 
\end{prob}

\begin{prob}\label{prob:histogram}
	Given a list of non-negative numbers, write a function that displays the
	histogram associated with this list. For example, if the argument is the
	list \lstinline{[1,4,2]}, the function should display 
\begin{lstlisting}
X
XXXX
XX
\end{lstlisting}
\end{prob}

\begin{prob}
	Write a function that given a list of words returns the longest one. 
\end{prob}

\begin{prob}
	Write a function that transforms a given number of seconds in days, hours,
	minutes and seconds.
\end{prob}

\begin{prob}
	Write a function that returns the average value of a given list of numbers.
\end{prob}

\begin{prob}
	Write a function that, given a letter, returns \lstinline{true} if the
	letter is a vowel and \lstinline{false} otherwise.
\end{prob}

\begin{prob}
	\label{prob:charmin}
	Use \lstinline{CharacteristicPolynomial} to compute the characteristic
	polynomial of the matrix
	$\begin{pmatrix}
		0 & -1 & 1\\
		1 & 2 & -1\\
		1 & 1 & 0
	\end{pmatrix}$.
	Can you compute the minimal polynomial?
\end{prob}

\begin{prob}
	\label{prob:division}
	Use the function \lstinline{QuotientRemainder} to compute the quotient and
	the remainder of $f=2x^4+3x^3+2x+4$ and $g=3x^2+x+2$ in the ring $\Z_5[x]$. 
\end{prob}

\begin{prob}
	\label{prob:mod}
	Compute $3x^{101}-15x^{16}-2x^7-5x^4+3x^3+2x^2+1\bmod x^3+1$. 
\end{prob}

\begin{prob}
	\label{prob:roots}
	Prove that $x=2$ is the only root in $\Z_5$ of $x^{1000}+4x+1\in\Z_5[x]$.
\end{prob}

\begin{prob}
	\label{prob:factors}
	Factorize $x^4-1$ in $\Z/5[x]$ and in $\Z/7[x]$.
\end{prob}

\begin{prob}
	\label{prob:primes}
	Prove that $x^2-79x+1601$ gives a prime number for
	$x\in\{0,1,\dots,79\}$.
\end{prob}

\begin{prob}
	\label{prob:twin}
	Write the first $50$ twin primes. 
\end{prob}

\index{Conway, J.}
\index{Fractran programming language}
\begin{prob}
	\label{prob:fractran}
	FRACTRAN is a programming language invented by J. Conway. A FRACTRAN program
	is simply an ordered list of positive rationals together with an initial
	positive integer input $n$. The program is run by updating the integer $n$
	as follows:
	\begin{itemize}
		\item For the first rational $f$ in the list for which $nf\in\Z$,
			replace $n$ by $nf$.
		\item Repeat this rule until no rational in the list produces an
			integer when multiplied by $n$, then stop.
	\end{itemize}
	Write an implementation of the FRACTRAN language. 

	Starting with $n=2$, the program 
	\begin{align*}
		\frac{17}{65}, \frac{133}{34}, \frac{17}{19}, \frac{23}{17}, \frac{2233}{69},
		\frac{23}{29}, \frac{31}{23}, \frac{74}{341}, \frac{31}{37}, \frac{41}{31}, \frac{129}{287}, \frac{41}{43}, \frac{13}{41}, \frac{1}{13}, \frac{1}{3}
	\end{align*}
	produces the sequence 
	\[
	2, 15, 825, 725, 1925, 2275, 425, 390, 330, 290, 770\dots
	\]
	In 1987, J. Conway proved that this sequence contains the set
	$\{2^p:p\text{ prime}\}$.  See \url{https://oeis.org/A007542} for more
	information.
\end{prob}

\index{Conway, J.}
\index{Look and say sequence}
\begin{prob}
	\label{prob:lookandsay}
	The first terms of Conway's ``look and say'' sequence are the following:
	\begin{lstlisting}
		1
		11
		21
		1211
		111221
		312211
	\end{lstlisting}
	After guessing how each term is computed, write a script to create the
	first terms of the sequence.
\end{prob}

%\begin{prob}
%	Let us play with finite-dimensional vector spaces. 
% vectores
%gap> v := [1,0,1];;
%gap> w := [2,0,2];;
%gap> v+3*w;
%[ 7, 0, 7 ]
%gap> v-w;
%[ -1, 0, -1 ]

\begin{prob}
    Write 
    \begin{align*}
	\binom{123456}{253461},
    &&
    \binom{123456789}{234517896},
    &&
    \binom{12345}{32451},
    \end{align*}
    as a product of disjoint cycles. 
\end{prob}

\begin{prob}
    Write the permutations 
    $(123)(45)(1625)(341)$ and 
    $(12)(245)(12)$
    as product of disjoint cycles.
\end{prob}

\begin{prob}
    Find a permutation $\tau$ such that 
    \begin{enumerate}
        \item $\tau(12)(34)\tau^{-1}=(56)(13)$.
        \item $\tau(123)(78)\tau^{-1}=(257)(13)$.
        \item $\tau(12)(34)(567)\tau^{-1}=(18)(23)(456)$.
    \end{enumerate}
\end{prob}
%
%%FIXME: perm como producto de trasposiciones
%
\begin{prob}
    Compute $\tau\sigma\tau^{-1}$ in the following cases:
    \begin{enumerate}
        \item $\sigma=(123)$ and $\tau=(34)$.
        \item $\sigma=(567)$ and $\tau=(12)(34)$.
    \end{enumerate}
\end{prob}

\begin{prob}
  Let $\sigma\in\Sym_{9}$ be given by $\sigma(i)=10-i$ for all
  $i\in\{1,\dots,9\}$. Write $\sigma$ as a product of disjoint cycles.
\end{prob}

\begin{prob}
    Find (if possible) three permutations $\alpha,\beta,\gamma\in\Sym_5$
    such that $\alpha\beta=\beta\alpha$, $\beta\gamma=\gamma\beta$ and
    $\alpha\gamma\ne\gamma\alpha$.
\end{prob}

\begin{prob}
  Use the function \lstinline{PermutationMat} to write the elements of $\Sym_3$
  as $3\times 3$ matrices. 
%% List(SymmetricGroup(3), x->PermutationMat(x,3));
\end{prob}

\begin{prob}
   For   
    $A=\begin{pmatrix}
        1 & 2 & 3\\
        4 & 5 & 6\\
        0 & 2 & 3
    \end{pmatrix}$ compute 
    \[
    I+A+\frac{1}{2!}A^2+\frac{1}{3!}A^3+\frac{1}{4!}A^{4}.
    \]
\end{prob}

\begin{prob}
    Write the funcion
    \[
    (n,A)\mapsto I+A+\frac{1}{2!}A^2+\frac{1}{3!}A^3+\cdots+\frac{1}{n!}A^{n}.
    \]
\end{prob}

\begin{prob}
  \index{Hilbert matrix}
  For $n\in\N$ the Hilbert matrix $H_n$ is defined as 
  \[
    (H_n)_{ij}=\frac{1}{i+j-1},\quad i,j\in\{1,\dots,n\}.
  \]
  Write the function $n\mapsto H_n$.
\end{prob}

\begin{prob}
  \index{Tensor product!of matrices}
  \index{Kronecker, L.}
  \index{Kronecker product}
  Use the function \lstinline{KroneckerProduct} to 
  compute
  \[
    \begin{pmatrix}
      1 & 2\\
      3 & 4
    \end{pmatrix}
    \otimes
    \begin{pmatrix}
      5 & 6 & 7\\
      2 & 1 & 0\\
      0 & 1 & 9
    \end{pmatrix}.
  \]
\end{prob}


\begin{prob}
	\label{prob:vsQ}
	Let $S$ be the vector space (over the rationals) generated by $(0,1,0)$ and
	$(0,0,1)$ and $T$ be generated by $(1,2,0)$ and $(3,1,2)$. Use
	\lstinline{VectorSpace} to create these vector spaces and compute $\dim S$,
	$\dim T$, $\dim(S\cap T)$ and $\dim(S+T)$.
\end{prob}

\begin{prob}
	\label{prob:withE(4)}
	Write the coordinates of the vector $(1,0,1)$ in the basis given by
	$(2i,1,0)$, $(2,-i,1)$, $(0,1+i,1-i)$. 
\end{prob}

\begin{prob}
  \index{Walsh matrix}
  Walsh matrices $H(2^k)$, $k\geq1$, are defined recursively as follows:
  \[
    H(2)=\begin{pmatrix}
      1 & 1\\
      1 & -1
    \end{pmatrix}
    ,\quad
    H(2^k)=H(2)\otimes H(2^{k-1}),\quad k\geq1,
  \]
  Construct the function $n\mapsto
  H(2^n)$. 
\end{prob}

\begin{prob}
  \label{prob:eigenvalues}
  \index{Eigenvector}
  \index{Eigenvalue}
  Use the functions \lstinline{Eigenvalues} and \lstinline{Eigenvalues} to
  compute the eigenvalues and eigenvectors of the matrix
  \[
    A=\begin{pmatrix}	
      1 & 2 & 3\\
      4 & 5 & 6\\
      6 & 7 & 8
    \end{pmatrix}\in\Q^{3\times3}.
  \]

  \textdbend The function \lstinline{Eigenvectors} returns generators of the eigenspaces,
  where $v\ne0$ is an eigenvector of $A$ with eigenvalue $\lambda$ if and only
  if $vA=\lambda v$. 
\end{prob}

\begin{prob}
  Use the function \lstinline{NullspaceMat} to compute the nullspace 
  of the matrix $A$ from problem~\ref{prob:eigenvalues}. 
  
  \textdbend 
  The nullspace of $A$ is defined as the set of vectors $v$ such
  that $vA=0$. 
\end{prob}


% otro ejercicio
%\end{prob
